import { Plugin } from 'rollup';
import { PluginOption } from 'vite';

interface PackageMeta {
    name: string;
    author?: string | {
        name: string;
        email?: string;
        url?: string;
    };
    license?: string | {
        type: string;
        url?: string;
    };
    licenses?: string | Array<{
        type: string;
        url?: string;
    }>;
    repository?: {
        url: string;
    };
    version: string;
}
interface LicenseMeta {
    author: PackageMeta['author'];
    name: string;
    license: string;
    licenseText: string;
    repository: string;
    source: string;
    version: string;
}
interface TestMocks {
    getLicense?: typeof getLicense;
    getLicenseFileName?: typeof getLicenseFileName;
    readLicenseFileContents?: typeof readLicenseFileContents;
    readPackageMeta?: (moduleDir: string, originalMethod: typeof readPackageMeta) => Promise<PackageMeta>;
}
interface PluginOptions {
    /**
     * Defines additional files that should be generated by this plugin
     * (e.g. an html representation of the licenses in addition to the
     * generated json)
     *
     * Keys represent filenames, values are functions that get invoked
     * with the packages array and should return the content written to
     * the additional file.
     */
    additionalFiles?: {
        [filename: string]: (packages: LicenseMeta[]) => string | Promise<string>;
    };
    /**
     * Defines an object to override licenses for specified package versions.
     *
     * Keys have the format <name>@<version>, values are valid spdx license
     * expressions.
     */
    licenseOverrides?: {
        [packageVersion: string]: string;
    };
    /**
     * Path to the output file that will be generated (relative to the bundle
     * output directory). Defaults to `oss-licenses.json`.
     */
    outputFilename?: string;
    /**
     * When this is enabled, packages where no license text was found get their
     * license text from spdx.org. Defaults to `false`.
     */
    replenishDefaultLicenseTexts?: boolean;
    /**
     * A method to define license identifiers as unacceptable. It is invoked
     * with the licenseIdentifier of every package and should return `true` when
     * the license is unacceptable and encountering it should fail the build.
     */
    unacceptableLicenseTest?: (licenseIdentifier: string) => boolean;
    /**
     * A method to exclude packages from the process. It is invoked with
     * packageName and packageVersion of every package and should return
     * `true` to exclude the package.
     */
    excludedPackageTest?: (packageName: string, packageVersion: string) => boolean;
    /**
     * Used to define packages that should always be included in the output.
     * It must return an array containing the absolute paths of those packages.
     * This function can be async or return a Promise.
     */
    includePackages?: () => string[] | Promise<string[]>;
    /**
     * Sets preferred licenses in case multiple licenses for a package
     * can be chosen from.
     */
    preferredLicenses?: string[];
    /** internal use for mocking */
    __mocks__?: TestMocks;
}
declare function readPackageMeta(moduleDir: string): Promise<PackageMeta>;
declare function getLicenseFileName(moduleDir: string): Promise<string | undefined>;
declare function readLicenseFileContents(path: string): Promise<string>;
declare function getLicense(packageId: string, meta: PackageMeta, pluginOptions?: PluginOptions): string;
declare function createRollupLicensePlugin(pluginOptions?: PluginOptions, pluginName?: string): Plugin;
declare function createViteLicensePlugin(pluginOptions?: PluginOptions): PluginOption;

export { type LicenseMeta, type PackageMeta, type PluginOptions, createRollupLicensePlugin, createViteLicensePlugin };
